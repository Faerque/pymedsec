Metadata-Version: 2.4
Name: pymedsec
Version: 0.1.0
Summary: HIPAA/GDPR-ready medical image sanitization and encryption library with blockchain audit anchoring
Home-page: https://github.com/example/pymedsec
Author: Healthcare Security Team
Author-email: Healthcare Security Team <security@example.com>
License: Apache-2.0
Project-URL: Homepage, https://github.com/example/pymedsec
Project-URL: Documentation, https://pymedsec.readthedocs.io/
Project-URL: Repository, https://github.com/example/pymedsec.git
Project-URL: Issues, https://github.com/example/pymedsec/issues
Project-URL: Changelog, https://github.com/example/pymedsec/blob/main/CHANGELOG.md
Keywords: medical,imaging,security,hipaa,gdpr,encryption,dicom,blockchain
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Healthcare Industry
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Scientific/Engineering :: Medical Science Apps.
Classifier: Topic :: Security :: Cryptography
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Operating System :: OS Independent
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: cryptography>=41.0.0
Requires-Dist: pydicom>=2.3.0
Requires-Dist: Pillow>=9.0.0
Requires-Dist: python-dateutil>=2.8.0
Requires-Dist: pyyaml>=6.0
Requires-Dist: click>=8.0.0
Requires-Dist: numpy>=1.20.0
Requires-Dist: importlib-resources>=5.0.0; python_version < "3.9"
Provides-Extra: dev
Requires-Dist: pytest>=7.0.0; extra == "dev"
Requires-Dist: pytest-cov>=4.0.0; extra == "dev"
Requires-Dist: black>=22.0.0; extra == "dev"
Requires-Dist: flake8>=5.0.0; extra == "dev"
Requires-Dist: build>=0.10.0; extra == "dev"
Requires-Dist: twine>=4.0.0; extra == "dev"
Provides-Extra: test
Requires-Dist: pytest>=7.0.0; extra == "test"
Requires-Dist: pytest-cov>=4.0.0; extra == "test"
Provides-Extra: ocr
Requires-Dist: pytesseract>=0.3.0; extra == "ocr"
Provides-Extra: aws
Requires-Dist: boto3>=1.26.0; extra == "aws"
Provides-Extra: vault
Requires-Dist: hvac>=1.0.0; extra == "vault"
Provides-Extra: blockchain
Requires-Dist: web3>=6.0.0; extra == "blockchain"
Dynamic: license-file

# Medical Image Security (pymedsec)

[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Python](https://img.shields.io/badge/python-3.8+-blue.svg)](https://www.python.org/downloads/)
[![PyPI](https://img.shields.io/pypi/v/pymedsec.svg)](https://pypi.org/project/pymedsec/)

A production-grade Python package for secure medical image processing with HIPAA/GDPR/GxP compliance features. This package implements envelope encryption with AES-256-GCM, comprehensive PHI sanitization, and tamper-evident audit logging for medical imaging workflows.

## ðŸ¥ Key Features

- **ðŸ”’ Envelope Encryption**: AES-256-GCM with KMS-managed key wrapping
- **ðŸ§¹ PHI Sanitization**: Comprehensive DICOM and EXIF metadata cleaning
- **ðŸ“Š Audit Logging**: Tamper-evident logs with HMAC signatures and rolling anchor hashes
- **â›“ï¸ Blockchain Anchoring**: Optional blockchain audit anchoring for tamper-evident compliance
- **ðŸ”Œ Pluggable KMS**: Support for AWS KMS, HashiCorp Vault, and mock providers
- **ðŸ§  ML-Ready**: Memory-only decryption for secure ML training workflows
- **ðŸ“‹ Compliance**: HIPAA, GDPR, and GxP alignment with comprehensive documentation

### Supported Formats

- **DICOM**: Full metadata extraction and sanitization
- **PNG**: EXIF metadata handling
- **JPEG**: EXIF, IPTC, and XMP metadata
- **TIFF**: Technical and EXIF metadata

## ðŸš€ Installation

```bash
# Install from PyPI
pip install pymedsec

# With development dependencies
pip install pymedsec[dev]

# With OCR support
pip install pymedsec[ocr]

# With AWS KMS support
pip install pymedsec[aws]

# With Vault KMS support  
pip install pymedsec[vault]
```

## ðŸ“– Public API

The pymedsec package provides a clean, minimal public API for secure medical image processing:

### Basic HIPAA Workflow

```python
from pymedsec import load_policy, scrub_dicom, get_kms_client, encrypt_blob, decrypt_to_tensor

# Load default HIPAA policy
policy = load_policy("hipaa_default")

# Create a mock KMS client for testing
kms = get_kms_client("mock")

# Process a DICOM file
raw = open("scan.dcm", "rb").read()
clean = scrub_dicom(raw, policy=policy, pseudo_pid="PX001")

# Encrypt with additional authenticated data
pkg = encrypt_blob(clean, kms_client=kms, aad={"dataset": "ds1", "modality": "CT"})

# Later: decrypt directly to tensor for ML processing
tensor = decrypt_to_tensor(pkg, kms_client=kms, format_hint="dicom")
print(f"Image shape: {tensor.shape}")
```

### Custom Policy with AWS KMS

```python
from pymedsec import load_policy, scrub_image, get_kms_client, encrypt_blob, decrypt_blob

# Load custom policy from file
policy = load_policy("/etc/policies/gxp_lab.yaml")

# Create AWS KMS client
kms = get_kms_client("aws", key_id="alias/prod-medimg", region_name="us-east-1")

# Process and encrypt an image
raw_image = open("scan.png", "rb").read()
clean_image = scrub_image(raw_image, format_hint="png", policy=policy)
pkg = encrypt_blob(clean_image, kms_client=kms, aad={"dataset": "trial42", "modality": "MRI"})

# Later: decrypt back to raw bytes
decrypted = decrypt_blob(pkg, kms_client=kms)
```

### ML Dataset Integration

```python
from pymedsec import SecureImageDataset, load_policy, get_kms_client

# Set up policy and KMS
policy = load_policy("hipaa_default")
kms = get_kms_client("mock")

# Create a dataset that decrypts on-the-fly
dataset = SecureImageDataset("./encrypted/", policy=policy, kms_client=kms)

# Iterate like a PyTorch dataset
for tensor in dataset:
    print(f"Sample shape: {tensor.shape}")
    break
```

## ðŸ”§ Legacy API

The package also provides the original detailed API for advanced use cases:

```python
from pymedsec import sanitize_image, encrypt_data, SecureImageLoader
from pymedsec.config import SecurityConfig
from pymedsec.kms.mock import MockKMSAdapter

# Load configuration
config = SecurityConfig.load_default()
kms = MockKMSAdapter()

# Sanitize a DICOM image
sanitized = sanitize_image("patient_scan.dcm", config)

# Encrypt the sanitized data
with open("patient_scan.dcm", "rb") as f:
    image_data = f.read()

encrypted_package = encrypt_data(image_data, config, kms)

# Save encrypted package
with open("patient_scan.enc", "w") as f:
    f.write(encrypted_package.to_json())

# ML Training Workflow with SecureImageLoader
for encrypted_path in dataset:
    with SecureImageLoader(encrypted_path, kms) as image:
        # Image data is decrypted in memory only
        batch_data = preprocess(image.data)
        model.train_on_batch(batch_data, labels)
    # Image automatically cleared from memory
```

### CLI Usage

```bash
# Set required environment variables
export PYMEDSEC_POLICY=/path/to/policy.yaml
export PYMEDSEC_KMS_BACKEND=mock
export PYMEDSEC_KMS_KEY_REF=dev-key
export PYMEDSEC_AUDIT_PATH=/tmp/audit.jsonl

# Sanitize a DICOM file
pymedsec sanitize --in patient.dcm --out sanitized.dcm --pseudo PX123 --format dicom

# Encrypt the sanitized image
pymedsec encrypt --in sanitized.dcm --out encrypted.pkg.json --kms dev-key --dataset study2025 --modality CT

# Decrypt (in memory by default)
pymedsec decrypt --in encrypted.pkg.json --out decrypted.dcm

# Verify integrity
pymedsec verify --in encrypted.pkg.json

# Verify blockchain anchors (if enabled)
pymedsec verify-blockchain --details

# Check audit status with blockchain
pymedsec audit-status --blockchain
```

## âš™ï¸ Configuration

### Environment Variables

| Variable                     | Description                                   | Default       |
| ---------------------------- | --------------------------------------------- | ------------- |
| `PYMEDSEC_POLICY`            | Path to YAML policy file                      | Required      |
| `PYMEDSEC_KMS_BACKEND`       | KMS backend (aws\|vault\|mock)                | mock          |
| `PYMEDSEC_KMS_KEY_REF`       | KMS key identifier                            | Required      |
| `PYMEDSEC_AUDIT_PATH`        | Audit log file path                           | ./audit.jsonl |
| `PYMEDSEC_NO_PLAINTEXT_DISK` | Forbid plaintext disk writes                  | false         |
| `PYMEDSEC_OCR_REDACTION`     | Enable OCR-based redaction                    | false         |
| `PYMEDSEC_REQUIRE_TEE`       | Require trusted execution environment         | false         |
| `PYMEDSEC_ACTOR`             | Actor name for audit logs                     | os.getlogin() |
| `PYMEDSEC_DEBUG`             | Enable debug logging                          | false         |
| `BLOCKCHAIN_BACKEND`         | Blockchain backend (ethereum\|mock\|disabled) | disabled      |
| `ETHEREUM_RPC_URL`           | Ethereum RPC endpoint URL                     | -             |
| `ETHEREUM_PRIVATE_KEY`       | Ethereum private key for transactions         | -             |

## Policy Configuration

Create a YAML policy file (see `policies/` directory for examples):

```yaml
schema_version: '1.0'
name: 'HIPAA Default Policy'
description: 'Default policy for HIPAA compliance'

sanitization:
  dicom:
    remove_private_tags: true
    regenerate_uids: true
    preserve_technical_tags: true
    burned_in_annotation_policy: 'strict'

  exif:
    strip_all_metadata: true
    preserve_orientation: false

encryption:
  algorithm: 'AES-256-GCM'
  key_rotation_days: 90
  require_kms: true

audit:
  log_all_operations: true
  include_file_hashes: true
  retention_days: 2557 # 7 years

compliance:
  hipaa_mode: true
  gdpr_mode: true
  purpose_limitation: 'medical_research'
  data_minimization: true
```

## Programming Interface

```python
from healthcare_imgsec import config, intake, crypto, sanitize

# Load configuration
cfg = config.load_config()

# Sanitize and encrypt a DICOM file
with intake.DicomReader("/path/to/patient.dcm") as reader:
    # Sanitize
    sanitized_data, report = sanitize.sanitize_dicom(
        reader.dataset,
        pseudo_pid="PX123"
    )

    # Convert to tensor for ML
    tensor = intake.to_tensor(sanitized_data, format_hint="dicom")

    # Encrypt
    encrypted_pkg = crypto.encrypt_data(
        sanitized_data.to_bytes(),
        kms_key_ref=cfg.kms_key_ref,
        dataset_id="study2025",
        modality="CT"
    )
```

## Security Model

### Envelope Encryption

Each medical image is encrypted using a unique AES-256-GCM data key:

1. Generate 256-bit data key + 96-bit nonce
2. Encrypt image data with AES-256-GCM
3. Wrap data key using KMS/HSM
4. Store wrapped key + ciphertext in envelope

### Audit Trail

All operations generate tamper-evident audit logs:

- JSONL format with HMAC line signing
- Includes actor, timestamp, operation, outcome
- Rolling anchor hashes every 1000 lines
- Supports SIEM integration

### Access Control

- Policy-driven access controls
- Optional TEE requirement validation
- KMS-based key access controls
- Memory-only decryption mode

## Compliance Documentation

- [HIPAA Readiness](docs/HIPAA_READINESS.md) - 45 CFR 164.312 mapping
- [GDPR Readiness](docs/GDPR_READINESS.md) - Data protection compliance
- [GxP/CLIA Alignment](docs/GXP_CLIA_ALIGNMENT.md) - Laboratory compliance
- [Architecture Overview](docs/ARCHITECTURE.md) - Security architecture
- [Validation Traceability](docs/VALIDATION_TRACEABILITY.md) - Requirements tracing

## Development

```bash
# Setup development environment
python -m venv .venv
source .venv/bin/activate
pip install -e ".[dev]"

# Run tests
make test

# Format code
make fmt

# Lint code
make lint
```

## OPERATIONS RUNBOOK

### Key Rotation

```bash
# 1. Create new KMS key
aws kms create-key --description "Healthcare Image Security Key v2"

# 2. Update policy with new key reference
export PYMEDSEC_KMS_KEY_REF=arn:aws:kms:region:account:key/new-key-id

# 3. Re-encrypt existing data (batch operation)
pymedsec batch-reencrypt --old-key old-key-id --new-key new-key-id --dataset study2025
```

### Incident Response - Key Compromise

```bash
# 1. Immediately disable compromised key
aws kms disable-key --key-id compromised-key-id

# 2. Identify affected datasets
grep "compromised-key-id" /var/log/pymedsec/audit.jsonl

# 3. Revoke access to encrypted data
# Note: Data becomes permanently inaccessible without key recovery

# 4. Notify stakeholders of data loss impact
echo "Dataset study2025 compromised - key revoked" | mail -s "SECURITY INCIDENT" security@example.com
```

### SIEM Integration

Forward audit logs to your SIEM system:

```bash
# Fluent Bit configuration for audit log forwarding
[INPUT]
    Name tail
    Path /var/log/pymedsec/audit.jsonl
    Parser json
    Tag pymedsec.audit

[OUTPUT]
    Name forward
    Match pymedsec.audit
    Host siem.example.com
    Port 24224
```

### Monitoring & Alerting

Key metrics to monitor:

- Encryption/decryption operation rates
- KMS key usage patterns
- Audit log integrity failures
- Policy violation attempts
- Nonce reuse detection

Sample CloudWatch alerts:

```bash
# High error rate alert
aws cloudwatch put-metric-alarm \
  --alarm-name "pymedsec-High-Error-Rate" \
  --alarm-description "High error rate in image security operations" \
  --metric-name "ErrorRate" \
  --namespace "pymedsec" \
  --statistic "Average" \
  --period 300 \
  --threshold 5.0 \
  --comparison-operator "GreaterThanThreshold"
```

### Backup & Recovery

- Audit logs: Daily backup to immutable storage
- Policies: Version control with approval workflow
- KMS keys: Cross-region replication for disaster recovery
- Encrypted data: Regular backup validation and restore testing

## Compliance Disclaimer

> **Important**: This package provides tools aligned with HIPAA/GDPR/GxP requirements but does not by itself ensure compliance. Compliance depends on deployment environment, policies, and governance. Organizations must implement appropriate administrative, physical, and technical safeguards according to applicable regulations and their specific use cases.

## License

Apache License 2.0 - see [LICENSE](LICENSE) file for details.

## Security Reporting

Report security vulnerabilities to security@example.com. Do not create public GitHub issues for security problems.
